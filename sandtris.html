<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>サンドトリス</title>
<style>
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    background-color: #f0f0f0;
    font-family: Arial, sans-serif;
  }
  #gameBoard {
    position: relative;
    width: 300px;
    height: 500px;
    background-color: #fff;
    border: 2px solid #000;
  }
  .block {
    position: absolute;
    width: 30px;
    height: 30px;
  }
  .solid {
    background-color: #808080; /* 砂の代わりになるブロックの色 */
  }
  #scoreBoard {
    position: absolute;
    top: 10px;
    right: 20px;
    font-size: 24px;
  }
</style>
</head>
<body>
<div id="gameBoard">
  <div id="scoreBoard">スコア: 0</div>
</div>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const board = document.getElementById('gameBoard');
    const scoreBoard = document.getElementById('scoreBoard');
    const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3']; // 7色
    const shapes = [
      [{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 60, y: 0 }, { x: 90, y: 0 }], // I
      [{ x: 0, y: 0 }, { x: 0, y: 30 }, { x: 30, y: 30 }, { x: 60, y: 30 }], // J
      [{ x: 0, y: 30 }, { x: 30, y: 30 }, { x: 60, y: 30 }, { x: 60, y: 0 }], // L
      [{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 0, y: 30 }, { x: 30, y: 30 }], // O
      [{ x: 0, y: 30 }, { x: 30, y: 30 }, { x: 30, y: 0 }, { x: 60, y: 0 }], // S
      [{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 60, y: 0 }, { x: 30, y: 30 }], // T
      [{ x: 0, y: 0 }, { x: 30, y: 0 }, { x: 30, y: 30 }, { x: 60, y: 30 }]  // Z
    ];
    let blocks = [];
    let interval = null;
    let score = 0;
    let rotation = 0;

    function updateScore(points) {
      score += points;
      scoreBoard.textContent = `スコア: ${score}`;
    }

    function createBlock() {
      const color = colors[Math.floor(Math.random() * colors.length)];
      const shape = shapes[Math.floor(Math.random() * shapes.length)];
      blocks = shape.map(pos => {
        const block = document.createElement('div');
        block.className = 'block';
        block.style.backgroundColor = color;
        block.style.top = pos.y + 'px';
        block.style.left = 120 + pos.x + 'px';
        board.appendChild(block);
        return block;
      });
    }

    function moveBlock() {
      interval = setInterval(() => {
        let canMove = true;
        blocks.forEach(block => {
          const top = parseInt(block.style.top);
          const belowBlock = board.querySelector(`.solid[top="${top + 30}px"][left="${block.style.left}"]`);
          if (top >= 470 || belowBlock) {
            canMove = false;
          }
        });

        if (canMove) {
          blocks.forEach(block => {
            const top = parseInt(block.style.top);
            block.style.top = top + 30 + 'px';
          });
        } else {
          clearInterval(interval);
          blocks.forEach(block => changeToSolids(block));
          updateScore(10);
          checkForMatches();
          createBlock();
          moveBlock();
        }
      }, 500);
    }

    function changeToSolids(block) {
      block.classList.add('solid');
    }

    function checkForMatches() {
      const allBlocks = [...board.getElementsByClassName('solid')];
      const rows = Array.from({ length: 17 }, () => []); // 17 rows in 500px height
      const cols = Array.from({ length: 10 }, () => []); // 10 columns in 300px width

      allBlocks.forEach(block => {
        const top = parseInt(block.style.top);
        const left = parseInt(block.style.left);
        rows[top / 30].push(block);
        cols[left / 30].push(block);
      });

      let toRemove = [];

      rows.forEach(row => {
        let match = row.reduce((acc, block, index, array) => {
          const prev = array[index - 1];
          if (prev && prev.style.backgroundColor === block.style.backgroundColor) {
            acc.push(block);
          } else if (acc.length >= 4) {
            acc.push(prev);
            acc.forEach(b => toRemove.push(b));
            acc = [block];
          } else {
            acc = [block];
          }
          return acc;
        }, []);

        if (match.length >= 4) {
          toRemove = toRemove.concat(match);
        }
      });

      cols.forEach(col => {
        let match = col.reduce((acc, block, index, array) => {
          const prev = array[index - 1];
          if (prev && prev.style.backgroundColor === block.style.backgroundColor) {
            acc.push(block);
          } else if (acc.length >= 4) {
            acc.push(prev);
            acc.forEach(b => toRemove.push(b));
            acc = [block];
          } else {
            acc = [block];
          }
          return acc;
        }, []);

        if (match.length >= 4) {
          toRemove = toRemove.concat(match);
        }
      });

      toRemove = [...new Set(toRemove)];

      if (toRemove.length > 0) {
        updateScore(toRemove.length * 10);
        toRemove.forEach(block => board.removeChild(block));
      }
    }

    function rotateBlock(direction) {
      rotation += direction;
      blocks.forEach(block => {
        block.style.transform = `rotate(${rotation}deg)`;
      });
    }

    function handleKeyPress(e) {
      const moves = { ArrowLeft: -30, ArrowRight: 30 };
      const canMoveHorizontally = (dir) => blocks.every(block => {
        const left = parseInt(block.style.left) + dir;
        return left >= 0 && left < 300;
      });

      if (e.key in moves && canMoveHorizontally(moves[e.key])) {
        blocks.forEach(block => {
          const left = parseInt(block.style.left);
          block.style.left = left + moves[e.key] + 'px';
        });
      } else if (e.key === 'w' || e.key === 'W') {
        rotateBlock(90); // 右回転
      } else if (e.key === 'q' || e.key === 'Q') {
        rotateBlock(-90); // 左回転
      }
    }

    document.addEventListener('keydown', handleKeyPress);

    createBlock();
    moveBlock();
  });
</script>
</body>
</html>
